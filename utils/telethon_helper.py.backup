"""
Telethon Helper - управление Telegram клиентами
"""
from telethon import TelegramClient
from telethon.errors import FloodWaitError, SessionPasswordNeededError
from telethon.tl.functions.channels import InviteToChannelRequest
from telethon.tl.functions.messages import SendMessageRequest
import os
from datetime import datetime, timedelta

# Cache для клиентов (чтобы не создавать каждый раз)
_clients_cache = {}


def get_telethon_client(account_id):
    """
    Get or create Telethon client for account
    
    Args:
        account_id: Account ID from database
        
    Returns:
        TelegramClient instance
    """
    from models.account import Account
    from config import Config
    
    # Check cache
    if account_id in _clients_cache:
        return _clients_cache[account_id]
    
    # Get account from DB
    account = Account.query.get(account_id)
    if not account:
        raise ValueError(f"Account {account_id} not found")
    
    # Check session file
    if not os.path.exists(account.session_file_path):
        raise FileNotFoundError(f"Session file not found: {account.session_file_path}")
    
    # Get proxy if assigned
    proxy = None
    if account.proxy_id:
        from models.proxy import Proxy
        proxy_obj = Proxy.query.get(account.proxy_id)
        if proxy_obj and proxy_obj.status == "active":
            proxy = {
                "proxy_type": proxy_obj.type,
                "addr": proxy_obj.host,
                "port": proxy_obj.port,
                "username": proxy_obj.username,
                "password": proxy_obj.password
            }
    
    # Create client
    client = TelegramClient(
        account.session_file_path.replace(".session", ""),
        Config.TG_API_ID,
        Config.TG_API_HASH,
        proxy=proxy
    )
    
    # Cache it
    _clients_cache[account_id] = client
    
    return client


async def connect_client(account_id):
    """Connect Telethon client"""
    client = get_telethon_client(account_id)
    if not client.is_connected():
        await client.connect()
    return client


async def verify_session(account_id):
    """
    Verify that session is valid
    
    Returns:
        dict: {"success": bool, "user": User object or None, "error": str}
    """
    try:
        client = await connect_client(account_id)
        me = await client.get_me()
        return {
            "success": True,
            "user": me,
            "error": None
        }
    except Exception as e:
        return {
            "success": False,
            "user": None,
            "error": str(e)
        }


async def send_invite(account_id, channel_username, target_user_id):
    """
    Send invite to user
    
    Args:
        account_id: Account to use
        channel_username: Target channel
        target_user_id: User ID to invite
        
    Returns:
        dict: {"status": str, "error": str or None}
    """
    try:
        client = await connect_client(account_id)
        
        # Get channel entity
        channel = await client.get_entity(channel_username)
        
        # Get user entity
        user = await client.get_entity(target_user_id)
        
        # Send invite
        await client(InviteToChannelRequest(
            channel=channel,
            users=[user]
        ))
        
        return {"status": "success", "error": None}
        
    except FloodWaitError as e:
        return {"status": "flood_wait", "error": f"FloodWait: {e.seconds} seconds"}
    except Exception as e:
        error_msg = str(e)
        
        # Classify error
        if "USER_PRIVACY_RESTRICTED" in error_msg:
            return {"status": "user_privacy", "error": "User privacy settings"}
        elif "PEER_FLOOD" in error_msg:
            return {"status": "peer_flood", "error": "Too many requests"}
        elif "USER_NOT_MUTUAL_CONTACT" in error_msg:
            return {"status": "not_mutual", "error": "User not in contacts"}
        else:
            return {"status": "error", "error": error_msg}


async def send_dm(account_id, username, message_text, media_file=None):
    """
    Send DM to user
    
    Args:
        account_id: Account to use
        username: Target username
        message_text: Message text
        media_file: Optional media file path
        
    Returns:
        dict: {"status": str, "message_id": int or None, "error": str or None}
    """
    try:
        client = await connect_client(account_id)
        
        # Get user entity
        user = await client.get_entity(username)
        
        # Send message
        message = await client.send_message(
            entity=user,
            message=message_text,
            file=media_file if media_file else None
        )
        
        return {
            "status": "success",
            "message_id": message.id,
            "error": None
        }
        
    except FloodWaitError as e:
        return {
            "status": "flood_wait",
            "message_id": None,
            "error": f"FloodWait: {e.seconds} seconds"
        }
    except Exception as e:
        error_msg = str(e)
        
        if "USER_PRIVACY_RESTRICTED" in error_msg:
            return {"status": "user_privacy", "message_id": None, "error": "Privacy restricted"}
        elif "PEER_FLOOD" in error_msg:
            return {"status": "peer_flood", "message_id": None, "error": "Too many requests"}
        else:
            return {"status": "error", "message_id": None, "error": error_msg}


async def parse_channel_members(account_id, channel_username, limit=1000, filters=None):
    """
    Parse members from channel
    
    Args:
        account_id: Account to use for parsing
        channel_username: Channel to parse
        limit: Max users to parse
        filters: Dict with filters (exclude_bots, exclude_admins, etc.)
        
    Returns:
        list: List of parsed users
    """
    try:
        client = await connect_client(account_id)
        
        # Get channel
        channel = await client.get_entity(channel_username)
        
        # Get participants
        participants = await client.get_participants(
            channel,
            limit=limit
        )
        
        users = []
        for user in participants:
            # Apply filters
            if filters:
                if filters.get("exclude_bots") and user.bot:
                    continue
                if filters.get("exclude_admins") and hasattr(user, "admin_rights"):
                    continue
                if filters.get("exclude_without_username") and not user.username:
                    continue
            
            # Calculate priority score
            score = calculate_user_priority_score(user)
            
            users.append({
                "user_id": user.id,
                "username": user.username,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "is_bot": user.bot,
                "is_premium": user.premium if hasattr(user, "premium") else False,
                "has_photo": bool(user.photo),
                "priority_score": score
            })
        
        return users
        
    except Exception as e:
        raise Exception(f"Error parsing channel: {str(e)}")


def calculate_user_priority_score(user):
    """
    Calculate priority score for user (0-100)
    Higher = better quality
    """
    score = 50  # Base score
    
    # Has profile photo
    if user.photo:
        score += 20
    
    # Premium user
    if hasattr(user, "premium") and user.premium:
        score += 15
    
    # Has username
    if user.username:
        score += 10
    
    # Not bot
    if not user.bot:
        score += 5
    
    return min(score, 100)


async def get_channel_messages(account_id, channel_username, limit=100):
    """
    Get recent messages from channel/group
    
    Args:
        account_id: Account to use
        channel_username: Channel username
        limit: Number of messages to fetch
        
    Returns:
        list: List of messages
    """
    try:
        client = await connect_client(account_id)
        
        channel = await client.get_entity(channel_username)
        messages = await client.get_messages(channel, limit=limit)
        
        result = []
        for msg in messages:
            if msg.sender_id:
                sender = await msg.get_sender()
                result.append({
                    "message_id": msg.id,
                    "from_user_id": msg.sender_id,
                    "from_username": sender.username if sender else None,
                    "from_first_name": sender.first_name if sender else None,
                    "text": msg.text,
                    "date": msg.date
                })
        
        return result
        
    except Exception as e:
        raise Exception(f"Error getting messages: {str(e)}")


async def send_channel_message(account_id, channel_username, text, media_file=None, pin=False):
    """
    Send message to channel
    
    Args:
        account_id: Account to use
        channel_username: Channel username
        text: Message text
        media_file: Optional media file
        pin: Whether to pin the message
        
    Returns:
        dict: {"message_id": int, "error": None}
    """
    try:
        client = await connect_client(account_id)
        
        channel = await client.get_entity(channel_username)
        
        message = await client.send_message(
            entity=channel,
            message=text,
            file=media_file if media_file else None
        )
        
        if pin:
            await client.pin_message(channel, message.id)
        
        return {"message_id": message.id, "error": None}
        
    except Exception as e:
        return {"message_id": None, "error": str(e)}


def cleanup_clients():
    """Close all cached clients"""
    global _clients_cache
    for client in _clients_cache.values():
        try:
            client.disconnect()
        except:
            pass
    _clients_cache = {}

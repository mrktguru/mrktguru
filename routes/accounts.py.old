from flask import Blueprint, render_template, request, redirect, url_for, flash, jsonify
from utils.decorators import login_required
from models.account import Account, DeviceProfile, AccountSubscription
from models.proxy import Proxy
from database import db
from utils.device_emulator import generate_device_profile, get_random_warmup_channels
from utils.telethon_helper import verify_session
import os
from werkzeug.utils import secure_filename
import asyncio

accounts_bp = Blueprint("accounts", __name__)


@accounts_bp.route("/")
@login_required
def list_accounts():
    """List all accounts"""
    accounts = Account.query.order_by(Account.created_at.desc()).all()
    proxies = Proxy.query.filter_by(status="active").all()
    return render_template("accounts/list.html", accounts=accounts, proxies=proxies)


@accounts_bp.route("/upload", methods=["GET", "POST"])
@login_required
def upload():
    """Upload session files"""
    if request.method == "POST":
        files = request.files.getlist("session_files")
        
        if not files or files[0].filename == "":
            flash("No files selected", "error")
            return redirect(url_for("accounts.upload"))
        
        uploaded = 0
        skipped = 0
        errors = []
        
        for file in files:
            if file and file.filename.endswith(".session"):
                try:
                    filename = secure_filename(file.filename)
                    phone = filename.replace(".session", "")
                    
                    # Check if account already exists
                    existing = Account.query.filter_by(phone=phone).first()
                    if existing:
                        skipped += 1
                        continue
                    
                    # Save file
                    filepath = os.path.join("uploads/sessions", filename)
                    os.makedirs("uploads/sessions", exist_ok=True)
                    file.save(filepath)
                    
                    # Create account
                    account = Account(
                        phone=phone,
                        session_file_path=filepath,
                        status="pending",
                        health_score=100
                    )
                    db.session.add(account)
                    db.session.flush()
                    
                    # Create device profile
                    device = generate_device_profile()
                    device_profile = DeviceProfile(
                        account_id=account.id,
                        device_model=device["device_model"],
                        system_version=device["system_version"],
                        app_version=device["app_version"],
                        lang_code=device["lang_code"],
                        system_lang_code=device["system_lang_code"]
                    )
                    db.session.add(device_profile)
                    
                    uploaded += 1
                    
                except Exception as e:
                    errors.append(f"{file.filename}: {str(e)}")
        
        db.session.commit()
        
        # Show notifications
        if uploaded > 0:
            flash(f"Successfully uploaded {uploaded} session file(s)", "success")
        if skipped > 0:
            flash(f"Skipped {skipped} duplicate account(s)", "warning")
        for error in errors:
            flash(error, "error")
        
        return redirect(url_for("accounts.list_accounts"))
    
    proxies = Proxy.query.filter_by(status="active").all()
    return render_template("accounts/upload.html", proxies=proxies)


@accounts_bp.route("/<int:account_id>")
@login_required
def detail(account_id):
    """Account details"""
    account = Account.query.get_or_404(account_id)
    proxies = Proxy.query.filter_by(status="active").all()
    return render_template("accounts/detail.html", account=account, proxies=proxies)


@accounts_bp.route("/<int:account_id>/verify", methods=["POST"])
@login_required
def verify(account_id):
    """Verify account session and fetch user info"""
    from utils.telethon_helper import verify_session, connect_client
    
    account = Account.query.get_or_404(account_id)
    
    try:
        result = asyncio.run(verify_session(account_id))
        
        if result["success"]:
            account.status = "active"
            account.health_score = 100
            
            # Save Telegram user info
            user = result["user"]
            account.telegram_id = user.id if hasattr(user, "id") else None
            account.first_name = getattr(user, "first_name", None) or "User"
            account.last_name = getattr(user, "last_name", None)
            account.username = getattr(user, "username", None)
            
            # Try to get full user info with bio
            try:
                client = asyncio.run(connect_client(account_id))
                full_user = asyncio.run(client.get_entity(user))
                if hasattr(full_user, "about"):
                    account.bio = full_user.about
            except:
                pass
            
            db.session.commit()
            
            username = account.username or "no username"
            flash(f"Session verified! User: {account.first_name} (@{username})", "success")
        else:
            account.status = "invalid"
            account.health_score = 0
            error_msg = result.get("error", "Unknown error")
            flash(f"Verification failed: {error_msg}", "error")
            db.session.commit()
        
    except Exception as e:
        account.status = "error"
        db.session.commit()
        flash(f"Error: {str(e)}", "error")
    
    return redirect(url_for("accounts.detail", account_id=account_id))


@accounts_bp.route("/<int:account_id>/delete", methods=["POST"])
@login_required
def delete(account_id):
    """Delete account"""
    account = Account.query.get_or_404(account_id)
    
    # Delete session file
    if os.path.exists(account.session_file_path):
        os.remove(account.session_file_path)
    
    db.session.delete(account)
    db.session.commit()
    
    flash("Account deleted", "success")
    return redirect(url_for("accounts.list_accounts"))


@accounts_bp.route("/<int:account_id>/assign-proxy", methods=["POST"])
@login_required
def assign_proxy(account_id):
    """Assign proxy to account"""
    account = Account.query.get_or_404(account_id)
    proxy_id = request.form.get("proxy_id")
    
    if proxy_id:
        account.proxy_id = int(proxy_id)
        db.session.commit()
        flash("Proxy assigned", "success")
    else:
        account.proxy_id = None
        db.session.commit()
        flash("Proxy removed", "info")
    
    return redirect(url_for("accounts.detail", account_id=account_id))


@accounts_bp.route("/<int:account_id>/add-subscription", methods=["POST"])
@login_required
def add_subscription(account_id):
    """Add channel subscription - actually joins the channel/group"""
    from utils.telethon_helper import connect_client
    from telethon.tl.functions.channels import JoinChannelRequest
    
    account = Account.query.get_or_404(account_id)
    channel_input = request.form.get("channel_username", "").strip()
    notes = request.form.get("notes", "").strip()
    
    if not channel_input:
        flash("Channel username is required", "error")
        return redirect(url_for("accounts.detail", account_id=account_id))
    
    # Extract username from various formats:
    # @username, username, t.me/username, https://t.me/username
    channel_username = channel_input.lstrip("@")
    if "t.me/" in channel_username:
        channel_username = channel_username.split("t.me/")[-1].split("/")[0].split("?")[0]
    
    # Check if already exists
    existing = AccountSubscription.query.filter_by(
        account_id=account_id,
        channel_username=channel_username
    ).first()
    
    if existing:
        flash(f"Already subscribed to @{channel_username}", "warning")
        return redirect(url_for("accounts.detail", account_id=account_id))
    
    # Try to join via Telethon
    subscription_status = "failed"
    try:
        client = asyncio.run(connect_client(account_id))
        entity = asyncio.run(client.get_entity(channel_username))
        
        # Try to join
        try:
            asyncio.run(client(JoinChannelRequest(entity)))
            subscription_status = "active"
            flash(f"Successfully joined @{channel_username}", "success")
        except Exception as join_err:
            # Check if already member
            try:
                me = asyncio.run(client.get_me())
                participants = asyncio.run(client.get_participants(entity, limit=100))
                if any(p.id == me.id for p in participants):
                    subscription_status = "active"
                    flash(f"Already a member of @{channel_username}", "success")
                else:
                    flash(f"Could not join: {str(join_err)}", "warning")
            except:
                flash(f"Could not verify membership in @{channel_username}", "warning")
                
    except Exception as e:
        flash(f"Error: {str(e)}", "error")
    
    # Save subscription
    subscription = AccountSubscription(
        account_id=account_id,
        channel_username=channel_username,
        subscription_source="manual",
        status=subscription_status,
        notes=notes
    )
    db.session.add(subscription)
    db.session.commit()
    
    return redirect(url_for("accounts.detail", account_id=account_id))


@accounts_bp.route("/<int:account_id>/subscriptions/<int:sub_id>/remove", methods=["POST"])
@login_required
def remove_subscription(account_id, sub_id):
    """Remove subscription"""
    subscription = AccountSubscription.query.get_or_404(sub_id)
    
    if subscription.account_id != account_id:
        flash("Invalid subscription", "error")
        return redirect(url_for("accounts.detail", account_id=account_id))
    
    db.session.delete(subscription)
    db.session.commit()
    
    flash("Subscription removed", "info")
    return redirect(url_for("accounts.detail", account_id=account_id))


@accounts_bp.route("/<int:account_id>/update-profile", methods=["POST"])
@login_required
def update_profile(account_id):
    """Update editable profile fields"""
    account = Account.query.get_or_404(account_id)
    
    # Update editable fields
    if "username" in request.form:
        account.username = request.form["username"].strip().lstrip("@")
    
    if "bio" in request.form:
        account.bio = request.form["bio"].strip()
    
    # Handle photo upload
    if "photo" in request.files:
        photo = request.files["photo"]
        if photo and photo.filename:
            filename = secure_filename(f"{account.phone}_{photo.filename}")
            photo_path = os.path.join("uploads/photos", filename)
            os.makedirs("uploads/photos", exist_ok=True)
            photo.save(photo_path)
            account.photo_url = photo_path
    
    db.session.commit()
    flash("Profile updated successfully", "success")
    return redirect(url_for("accounts.detail", account_id=account_id))
